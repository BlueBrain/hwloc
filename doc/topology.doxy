/*
 * Copyright © 2009 CNRS, INRIA, Université Bordeaux 1
 *
 * This software is a computer program whose purpose is to provide
 * abstracted information about the hardware topology.
 *
 * This software is governed by the CeCILL-B license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL-B
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-B license and that you accept its terms.
 */
/*! \mainpage Libtopology

<h1 class="sub">Portable abstraction of hierarchical architectures for high-performance computing</h1>

<hr>

\htmlonly
<div class="section" id="introduction">
\endhtmlonly
\section Introduction

libtopology provides a portable abstraction (across OS, versions, architectures,
...) of the hierarchical topology of modern architectures. It primarily aims at
helping high-performance computing applications with gathering information about
the hardware so as to exploit it accordingly and efficiently.

libtopology provides a hierarchical view of the machine, NUMA memory nodes,
sockets, shared caches, cores and simultaneous multithreading. It also gathers
various attributes such as cache and memory information.

libtopology supports the following operating systems:

<ul>
  <li> Linux (including old kernels not having sysfs topology information, with
  knowledge of cpusets and offline cpus)
  <li> Solaris
  <li> AIX
  <li> Darwin
  <li> OSF/1 (aka. Tru64)
  <li> Windows
  <li> For other OSes, only the number of processors is available for now.
</ul>

For development and debugging purposes, libtopology also offers the ability to
work on fake topologies:

<ul>
  <li> Symmetrical tree of resources generated from a list of level arities
  <li> Remote machine simulation through the gathering of Linux sysfs topology files
</ul>

libtopology may also display the topology in a convenient format, either in
graphical mode, or by exporting in PDF, PNG, FIG, ... format, or in text mode
(see Examples below).

libtopology offers a programming interface for manipulating topologies and
objects. It also brings a powerful cpu bitmap API that is used to describe
topology objects location on physical/logical processors. See the \ref interface interface
below. It may also be used to binding applications onto certain cores or
memory nodes. Several utility programs are also provided to ease command-line
manipulation of topology objects, binding of processes, ...

\htmlonly
</div><div class="section" id="installation">
\endhtmlonly
\section installation Installation

libtopology (http://libtopology.gforge.inria.fr/) is available under the CeCILL-B license (BSD-like).
It is hosted by the INRIA Gforge (http://gforge.inria.fr/projects/libtopology/).
The current SVN snapshot can be fetched with:

<ul>
 <li>svn checkout svn://scm.gforge.inria.fr/svn/libtopology/trunk libtopology
 <li>cd libtopology
 <li>autoreconf -ifv
</ul>

Note that autoconf >=2.60, automake >=1.10 and libtool >=2.2.6 are required in that case.

Installation by itself is as usual:

<ul>
 <li>./configure --prefix=...
 <li>make
 <li>make install
</ul>

Lstopo's fig support is always available. To get support for pdf, ps and png
support, cairo is needed. To get support for xml, libxml2 is needed.

\htmlonly
</div><div class="section" id="examples">
\endhtmlonly
\section examples Examples

 On a 4-socket 2-core machine with hyperthreading, the \c lstopo tool may
 show the following outputs:

\image html dudley.png
\image latex dudley.png width=\textwidth

\code
Machine(15GB)
  Socket#0 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#0
      P#8
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#4
      P#12
  Socket#1 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#1
      P#9
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#5
      P#13
  Socket#2 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#2
      P#10
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#6
      P#14
  Socket#3 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#3
      P#11
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#7
      P#15
\endcode

 On a 8-socket 2-core Opteron NUMA machine, the \c lstopo tool may
 show the following outputs:

\image html hagrid.png
\image latex hagrid.png width=\textwidth

\code
Machine(62GB)
  NUMANode#0(8190MB) + Socket#0
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#0
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#1
  NUMANode#1(8192MB) + Socket#1
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#2
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#3
  NUMANode#2(8192MB) + Socket#2
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#4
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#5
  NUMANode#3(8192MB) + Socket#3
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#6
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#7
  NUMANode#4(8192MB) + Socket#4
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#8
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#9
  NUMANode#5(8192MB) + Socket#5
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#10
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#11
  NUMANode#6(8192MB) + Socket#6
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#12
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#13
  NUMANode#7(8192MB) + Socket#7
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#14
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#15
\endcode

 On a 2-socket quad-core Xeon (pre-Nehalem ones assembling 2 dual-core dies into each socket):

\image html emmett.png
\image latex emmett.png width=\textwidth

\code
Machine(15GB)
  Socket#0
    L2Cache(4096KB)
      L1Cache(32KB) + Core#0 + P#0
      L1Cache(32KB) + Core#1 + P#4
    L2Cache(4096KB)
      L1Cache(32KB) + Core#2 + P#2
      L1Cache(32KB) + Core#3 + P#6
  Socket#1
    L2Cache(4096KB)
      L1Cache(32KB) + Core#0 + P#1
      L1Cache(32KB) + Core#1 + P#5
    L2Cache(4096KB)
      L1Cache(32KB) + Core#2 + P#3
      L1Cache(32KB) + Core#3 + P#7
\endcode

\htmlonly
</div><div class="section" id="interface">
\endhtmlonly
\section interface Interface example

This section shows how to use libtopology with an small example \c topo-hello.c
that just prints the topology and binds itself to the first processor of the
second core of the machine.

Libtopology provides a pkg-config object, so compiling the example boils down to

\verbatim
CFLAGS+=$(pkg-config --cflags topology)
LDLIBS+=$(pkg-config --libs topology)
cc topo-hello.c $(CFLAGS) -o topo-hello $(LDLIBS)
\endverbatim

   \code
/* topo-hello.c */
#include <topology.h>

static void print_children(topo_topology_t topology, topo_obj_t obj, int depth)
{
	char string[128];
	int i;

	topo_obj_snprintf(string, sizeof(string), topology, obj, "#", 0);
	printf("%*s%s\n", 2*depth, "", string);
	for (i = 0; i < obj->arity; i++)
		print_children(topology, obj->children[i], depth + 1);
}

int main(void)
{
	/* Topology object */
	topo_topology_t topology;

	/* Allocate and initialize topology object.  */
	topo_topology_init(&topology);

        /* ... Optionally, put detection configuration here to e.g. ignore some
           objects types, define a synthetic topology, etc....  The default is
           to detect all the objects of the machine that the caller is allowed
           to access.
	   See Configure Topology Detection.  */

	/* Perform the topology detection.  */
	topo_topology_load(topology);


	/* Get topology information.  */
	struct topo_topology_info topoinfo;
	topo_topology_get_info(topology, &topoinfo);


	/* Walk the topology with an array style.  */
	unsigned depth, i;
	char string[128];
	for (depth = 0; depth < topoinfo.depth; depth++) {
		for (i = 0; i < topo_get_depth_nbobjs(topology, depth); i++) {
			topo_obj_snprintf(string, sizeof(string), topology,
					topo_get_obj(topology, depth, i), "#", 0);
			printf("%s\n", string);
		}
	}

	/* Walk the topology with a tree style.  */
	print_children(topology, topo_get_system_obj(topology), 0);


	/* Find out where cores are, or else smaller sets of CPUs.  */
	depth = topo_get_type_or_below_depth(topology, TOPO_OBJ_CORE);

	/* Get last one.  */
	topo_obj_t obj = topo_get_obj(topology, depth, topo_get_depth_nbobjs(topology, depth) - 1);
	if (!obj)
		return 0;

	/* Get its cpuset.  */
	topo_cpuset_t cpuset = obj->cpuset;

	/* Get only one logical processor (in case the core is SMT/hyperthreaded).  */
	topo_cpuset_singlify(&cpuset);

	/* And try to bind ourself there.  */
	if (topo_set_cpubind(topology, &cpuset, 0)) {
		char s[TOPO_CPUSET_STRING_LENGTH + 1];
		topo_cpuset_snprintf(s, sizeof(s), &obj->cpuset);
		printf("Couldn't bind to cpuset %s\n", s);
	}


	/* Destroy topology object.  */
	topo_topology_destroy(topology);

	return 0;
}
   \endcode

A lot of traversal examples are available in topology/helper.h .

Further documentation is available in manual pages, pdf, and html format
in the source tarball in doc/doxygen-doc/, after doxygen compilation
for svn checkouts, and are installed in the usual manual repository and
$prefix/share/doc/topology/.

To precisely define the vocabulary used by libtopology, a \ref glossary is available.

\htmlonly
</div><div class="section" id="bugs">
\endhtmlonly
\section bugs Bugs and questions

Bug reports and questions should be sent to the devel mailing list (http://lists.gforge.inria.fr/cgi-bin/mailman/listinfo/libtopology-devel).

\htmlonly
</div><div class="section" id="credits">
\endhtmlonly
\section Credits

\c libtopology is developed by the INRIA Runtime Team-Project (http://runtime.bordeaux.inria.fr/) (headed by Raymond Namyst http://dept-info.labri.fr/~namyst/).

\htmlonly
</div>
\endhtmlonly

\page glossary Glossary

<dl>

<dt>Object</dt>
  <dd>Interesting kind of part of the system, such as a Core, a Cache, a Memory
  node, etc. The different types detected by libtopology are detailed in the
  ::topo_obj_type_e enumeration.
  
  They are topologically sorted by CPU set into a tree whose root is the System object which always exists.
  </dd>

<dt>CPU set</dt>
  <dd>The set of logical processors logically included in an object, if any</dd>

<dt>Father object</dt>
  <dd>The object logically containing the current object, for instance because
  its CPU set includes the CPU set of the current object.
  </dd>

<dt>Children objects</dt>
  <dd>The object contained in the current object because their CPU set is
  included in the CPU set of the current object.</dd>

<dt>Arity</dt>
  <dd>The number of children of an object</dd>

<dt>Sibling objects</dt>
  <dd>Objects of the same type which have the same father</dd>

<dt>Sibling rank</dt>
  <dd>Index to uniquely identify objecst of the same type which have the same
  father, numbered from 0 to the arity of the father minus one.</dd>

<dt>Cousin objects</dt>
  <dd>Objects of the same type as the curren object</dd>

<dt>OS index</dt>
  <dd>The index that the OS uses to identify the object. This may sometimes be
  completely arbitrary or depend on the BIOS configuration.</dd>

<dt>Depth</dt>
  <dd>Nesting level in the object tree, starting from the System object.</dd>

<dt>Logical index</dt>
  <dd>Index to uniquely identify objects of the same type. This index is always
  linear to express proximity.  It could also be called cousin rank.</dd>

</dl>

A diagram can help understanding the vocabulary:

\image html diagram.png
\image latex diagram.eps width=\textwidth

It can be noticed that for Processor objects, the logical index, computed
linearly by libtopology, is not the same as the OS index.

TODO: add level pointers.

*/
