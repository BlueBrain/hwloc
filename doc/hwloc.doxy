/*
 * Copyright © 2009 CNRS, INRIA, Université Bordeaux 1
 * Copyright © 2009 Cisco Systems, Inc.  All rights reserved.
 * See COPYING in top-level directory.
 */

/*! \mainpage hwloc

<h1 class="sub">Portable abstraction of hierarchical architectures for high-performance computing</h1>

<hr>

\htmlonly
<div class="section" id="introduction">
\endhtmlonly
\section Introduction

hwloc provides command line tools and a C API to obtain the
hierarchical map of key computing elements, such as: NUMA memory
nodes, shared caches, processor sockets, processor cores, and
processor "threads".  hwloc also gathers various attributes such as
cache and memory information, and is portable across a variety of
different operating systems and platforms.

hwloc primarily aims at helping high-performance computing (HPC)
applications, but is also applicable to any project seeking to exploit
code and/or data locality on modern computing platforms.

*** Note that the hwloc project represents the merger of the
libtopology project from INRIA and the Portable Linux Processor
Affinity (PLPA) sub-project from Open MPI.  <em>Both of these prior
projects are now deprecated.</em> The first hwloc release is essentially a
"re-branding" of the libtopology code base, but with both a few
genuinely new features and a few PLPA-like features added in.  More
new features and more PLPA-like features will be added to hwloc over
time. See \ref switchfromplpa for more details about converting
your application from PLPA to hwloc.

hwloc supports the following operating systems:

<ul>
<li>Linux (including old kernels not having sysfs topology
information, with knowledge of cpusets, offline cpus, and Kerrighed
support)</li>
<li>Solaris</li>
<li>AIX</li>
<li>Darwin / OS X</li>
<li>*FreeBSD</li>
<li>OSF/1 (a.k.a., Tru64)</li>
<li>HP-UX</li>
<li>Microsoft Windows</li>
</ul>

hwloc only reports the number of processors on unsupported operating
systems; no topology information is available.

For development and debugging purposes, hwloc also offers the ability to
work on "fake" topologies:

<ul>
  <li> Symmetrical tree of resources generated from a list of level arities</li>
  <li> Remote machine simulation through the gathering of Linux sysfs topology files</li>
</ul>

hwloc can display the topology in a human-readable format, either in
graphical mode (X11), or by exporting in one of several different
formats, including: plain text, PDF, PNG, and FIG (see Examples
below).  Note that some of the export formats require additional
support libraries.

hwloc offers a programming interface for manipulating topologies and
objects. It also brings a powerful CPU bitmap API that is used to
describe topology objects location on physical/logical processors. See
the \ref interface below. It may also be used to binding applications
onto certain cores or memory nodes. Several utility programs are also
provided to ease command-line manipulation of topology objects,
binding of processes, and so on.

\htmlonly
</div><div class="section" id="installation">
\endhtmlonly
\section installation Installation

hwloc (http://www.open-mpi.org/projects/hwloc/) is available under the
BSD license.  It is hosted as a sub-project of the overall Open MPI
project (http://www.open-mpi.org/).  Note that hwloc does not require
any functionality from Open MPI -- it is a wholly separate (and much
smaller!) project and code base.  It just happens to be hosted as part
of the overall Open MPI project.

Nightly development snapshots are available on the web site.
Additionally, the code can be directly checked out of Subversion:

\code
shell$ svn checkout http://svn.open-mpi.org/svn/hwloc/trunk hwloc-trunk
shell$ cd hwloc-trunk
shell$ ./autogen.sh
\endcode

Note that GNU Autoconf >=2.60, Automake >=1.10 and Libtool >=2.2.6 are
required when building from a Subversion checkout.

Installation by itself is the fairly common GNU-based process:

\code
shell$ ./configure --prefix=...
shell$ make
shell$ make install
\endcode

The hwloc command-line tool "lstopo" produces human-readable topology
maps, as mentioned above.  It can also export maps to the "fig" file
format.  Support for PDF, Postscript, and PNG exporting is provided if
the "Cairo" development package can be found when hwloc is configured
and build.  Similarly, lstopo's XML support requires the libxml2
development package.

\htmlonly
</div><div class="section" id="examples">
\endhtmlonly
\section examples Examples

On a 4-socket 2-core machine with hyperthreading, the \c lstopo tool
may show the following outputs:

\image html dudley.png
\image latex dudley.png width=\textwidth

\verbatim
System(15GB)
  Socket#0 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core#0
      P#0
      P#8
    L2(1024KB) + L1(16KB) + Core#1
      P#4
      P#12
  Socket#1 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core#0
      P#1
      P#9
    L2(1024KB) + L1(16KB) + Core#1
      P#5
      P#13
  Socket#2 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core#0
      P#2
      P#10
    L2(1024KB) + L1(16KB) + Core#1
      P#6
      P#14
  Socket#3 + L3(4096KB)
    L2(1024KB) + L1(16KB) + Core#0
      P#3
      P#11
    L2(1024KB) + L1(16KB) + Core#1
      P#7
      P#15
\endverbatim

 On a 4-socket 2-core Opteron NUMA machine, the \c lstopo tool may
 show the following outputs:

\image html hagrid.png
\image latex hagrid.png width=\textwidth

\verbatim
System(62GB)
  Node#0(8190MB) + Socket#0
    L2(1024KB) + L1(64KB) + Core#0 + P#0
    L2(1024KB) + L1(64KB) + Core#1 + P#1
  Node#1(8192MB) + Socket#1
    L2(1024KB) + L1(64KB) + Core#0 + P#2
    L2(1024KB) + L1(64KB) + Core#1 + P#3
  Node#2(8192MB) + Socket#2
    L2(1024KB) + L1(64KB) + Core#0 + P#4
    L2(1024KB) + L1(64KB) + Core#1 + P#5
  Node#3(8192MB) + Socket#3
    L2(1024KB) + L1(64KB) + Core#0 + P#6
    L2(1024KB) + L1(64KB) + Core#1 + P#7
  Node#4(8192MB) + Socket#4
    L2(1024KB) + L1(64KB) + Core#0 + P#8
    L2(1024KB) + L1(64KB) + Core#1 + P#9
  Node#5(8192MB) + Socket#5
    L2(1024KB) + L1(64KB) + Core#0 + P#10
    L2(1024KB) + L1(64KB) + Core#1 + P#11
  Node#6(8192MB) + Socket#6
    L2(1024KB) + L1(64KB) + Core#0 + P#12
    L2(1024KB) + L1(64KB) + Core#1 + P#13
  Node#7(8192MB) + Socket#7
    L2(1024KB) + L1(64KB) + Core#0 + P#14
    L2(1024KB) + L1(64KB) + Core#1 + P#15
\endverbatim

 On a 2-socket quad-core Xeon (pre-Nehalem, with 2 dual-core dies into
 each socket):

\image html emmett.png
\image latex emmett.png "" width=8cm

\verbatim
System(15GB)
  Socket#0
    L2(4096KB)
      L1(32KB) + Core#0 + P#0
      L1(32KB) + Core#1 + P#4
    L2(4096KB)
      L1(32KB) + Core#2 + P#2
      L1(32KB) + Core#3 + P#6
  Socket#1
    L2(4096KB)
      L1(32KB) + Core#0 + P#1
      L1(32KB) + Core#1 + P#5
    L2(4096KB)
      L1(32KB) + Core#2 + P#3
      L1(32KB) + Core#3 + P#7
\endverbatim

\htmlonly
</div><div class="section" id="interface">
\endhtmlonly

\section interface Programming interface

The basic interface is available in hwloc.h. It mostly offers
low-level routines for advanced programmers that want to manually
manipulate objects and follow links between them.  Developers should
look at hwloc/helper.h, which provides good higher-level topology
traversal examples.

Each object contains a cpuset describing the list of processors that
it contains.  These cpusets may be used for \ref hwlocality_binding.
hwloc offers an extensive cpuset manipulation interface in
hwloc/cpuset.h.

Moreover, hwloc also comes with additional helpers for
interoperability with several commonly used environments.  For Linux,
some specific helpers are available in hwloc/linux.h, and
hwloc/linux-libnuma.h if using libnuma.  On glibc-based systems,
additional helpers are available in hwloc/glibc-sched.h.  For Linux
systems with the OpenFabrics verbs library, some dedicated helpers are
provided in hwloc/openfabrics-verbs.h (this helper file is not yet
useful on non-Linux systems with the OpenFabrics verbs library).

To precisely define the vocabulary used by hwloc, a \ref glossary is
available and should probably be read first.

Further documentation is available in a full set of HTML pages, man
pages, and self-contained PDF files (formatted for both both US letter
and A4 formats) in the source tarball in doc/doxygen-doc/.  If you are
building from a Subversion checkout, you will need to have Doxygen and
pdflatex installed -- the documentation will be built during the
normal "make" process.  The documentation is installed during "make
install" to $prefix/share/doc/hwloc/ and your systems default man page
tree (under $prefix, of course).

The following section presents an example of API usage.

\section interface_example API example

The following small C example (named ``hwloc-hello.c'') prints the
topology of the machine and bring the process to the first processor
of the second core of the machine.

\include hwloc-hello.c

hwloc provides a \c pkg-config executable to obtain relevant compiler
and linker flags.  For example, it can be used thusly to compile
applications that utilize the hwloc library (assuming GNU Make):

\verbatim
CFLAGS += $(pkg-config --cflags hwloc)
LDLIBS += $(pkg-config --libs hwloc)
cc hwloc-hello.c $(CFLAGS) -o hwloc-hello $(LDLIBS)
\endverbatim

On a machine with 4GB of RAM and 2 processor sockets -- each socket of
which has two processor cores -- the output from running \c
hwloc-hello could be something like the following:

\verbatim
shell$ ./hwloc-hello
*** Objects at level 0
Index 0: System(3938MB)
*** Objects at level 1
Index 0: Socket#0
Index 1: Socket#1
*** Objects at level 2
Index 0: Core#0
Index 1: Core#1
Index 2: Core#3
Index 3: Core#2
*** Objects at level 3
Index 0: P#0
Index 1: P#1
Index 2: P#2
Index 3: P#3
*** Printing overall tree
System(3938MB)
  Socket#0
    Core#0
      P#0
    Core#1
      P#1
  Socket#1
    Core#3
      P#2
    Core#2
      P#3
*** 2 socket(s)
shell$ 
\endverbatim

\htmlonly
</div><div class="section" id="bugs">
\endhtmlonly
\section bugs Questions and bugs

Questions should be sent to the devel mailing
list (http://www.open-mpi.org/community/lists/hwloc.php).
Bug reports should be reported in the tracker
(https://svn.open-mpi.org/trac/hwloc/).

\htmlonly
</div><div class="section" id="credits">
\endhtmlonly
\section history History / credits

hwloc is the evolution and merger of the libtopology
(http://runtime.bordeaux.inria.fr/libtopology/) project and the Portable
Linux Processor Affinity (PLPA) (http://www.open-mpi.org/projects/plpa/)
project. Because of functional and ideological overlap, these two code bases
and ideas were merged and released under the name "hwloc" as an Open MPI
sub-project.

libtopology was initially developed by the INRIA Runtime Team-Project
(http://runtime.bordeaux.inria.fr/) (headed by Raymond Namyst
(http://dept-info.labri.fr/~namyst/). PLPA was initially developed by
the Open MPI development team as a sub-project. Both are now deprecated
in favor of hwloc, which is distributed as an Open MPI sub-project.

\htmlonly
</div>
\endhtmlonly



\page glossary Glossary

<dl>

<dt>Object</dt>
  <dd>Interesting kind of part of the system, such as a Core, a Cache,
  a Memory node, etc. The different types detected by hwloc are
  detailed in the ::hwloc_obj_type_t enumeration.
  
  They are topologically sorted by CPU set into a tree whose root is
  the System object (which always exists).
  </dd>

<dt>CPU set</dt>
  <dd>The set of logical processors logically included in an object
  (if any).  This term does \em not have any relation to an operating
  system ``CPU set.''</dd>

<dt>Father object</dt>
  <dd>The object logically containing the current object, for example
  because its CPU set includes the CPU set of the current object.</dd>

<dt>Children object(s)</dt>
  <dd>The object (or objects) contained in the current object because
  their CPU set is included in the CPU set of the current object.</dd>

<dt>Arity</dt>
  <dd>The number of children of an object.</dd>

<dt>Sibling objects</dt>
  <dd>Objects of the same type which have the same father.</dd>

<dt>Sibling rank</dt>
  <dd>Index to uniquely identify objects of the same type which have
  the same father, and is always in the range [0, fathers_arity).</dd>

<dt>Cousin objects</dt>
  <dd>Objects of the same type as the current object.</dd>

<dt>Level</dt>
  <dd>Set of objects of the same type.</dd>

<dt>OS index</dt>
  <dd>The index that the operating system (OS) uses to identify the
  object.  This may be completely arbitrary, or it may depend on the
  BIOS configuration.</dd>

<dt>Depth</dt>
  <dd>Nesting level in the object tree, starting from the 0th object
  (i.e., the System object).</dd>

<dt>Logical index</dt>
  <dd>Index to uniquely identify objects of the same type.  It
  expresses proximity in a generic way.  This index is always linear
  and in the range [0, num_objs_same_type_same_level).  Think of it
  as ``cousin rank.'' The ordering is based on topology first, and
  then on OS CPU numbers, so it is stable across everything except
  firmware CPU renumbering.</dd>

</dl>

The following diagram can help to understand the vocabulary of the
relationships by showing the example of a machine with two dual core
sockets (with no hardware threads); thus, a topology with 4 levels.

\image html diagram.png
\image latex diagram.eps width=\textwidth

It should be noted that for Processor objects, the logical index -- as
computed linearly by hwloc -- is not the same as the OS index.



\page tools Command-line tools 

hwloc comes with an extensive C programming interface and several
command line utilities. Each of them is fully documented in its
own manual page.

\section cli_lstopo lstopo

lstopo (also known as hwloc-info and hwloc-ls)
displays the hierarchical topology of the current system.
The output may be graphic or textual, and exported to numerous
graphic file formats such as PDF or PNG.

lstopo may also display other system topologies thanks to XML
input files for instance.

\section cli_hwloc_bind hwloc-bind

hwloc-bind lets you bind processes to specific hardware objects through
a flexible syntax. You may specify multiple objects, objects within
objects, cpusets, ...
See the hwloc-bind(1) man page for more details.

hwloc-bind may also retrieve the current binding.

\section cli_hwloc_mask hwloc-mask

hwloc-mask generates cpuset strings from given hardware objects
with the ability to aggregate them, intersect them, and more.

hwloc-mask uses the same syntax than hwloc-bind, but multiple instances
may be composed to generate complex combinations.
The generated cpuset string may for instance be passed to hwloc-bind
later for binding.

hwloc-mask may also generate lists of logical processors or NUMA nodes
that are convenient to pass to some external tools such as taskset or
numactl.

\section cli_hwloc_distrib hwloc-distrib

hwloc-distrib generates a set of cpuset strings that are uniformly
distributed across the machine for the given number of processes.
These strings may be used with hwloc-bind to run processes so as to
maximize their memory bandwidth by properly distributing them across
the machine.



\page envvar Environment variables

The behavior of the hwloc library and tools may be tuned thanks to the
following environment variables.

<dt>HWLOC_XMLFILE=/path/to/file.xml</dt>
  <dd>enforces the discovery from the given XML file as if
  hwloc_topology_set_xml() had been called.
  This file may have been generated earlier with lstopo file.xml.
  For conveniency, this backend provides empty binding hooks which just
  return success.  To have hwloc still actually call OS-specific hooks,
  HWLOC_THISSYSTEM should be set 1 in the environment too, to assert that
  the loaded file is really the underlying system.
  </dd>

<dt>HWLOC_FSROOT=/path/to/linux/filesystem-root/</dt>
  <dd>switches to reading the topology from the specified
  Linux filesystem root instead of the main file-system root, as if
  hwloc_topology_set_fsroot() had been called.
  Not using the main file-system root causes hwloc_topology_is_thissystem()
  to return 0.
  For conveniency, this backend provides empty binding hooks which just
  return success.  To have hwloc still actually call OS-specific hooks,
  HWLOC_THISSYSTEM should be set 1 in the environment too, to assert that
  the loaded file is really the underlying system.
  </dd>

<dt>HWLOC_THISSYSTEM=1</dt>
  <dd>enforces the return value of hwloc_topology_is_thissystem().
  It means that it makes hwloc assume that the selected backend provides the
  topology for the system on which we are running, even if it is not the
  OS-specific backend but the XML backend for instance.
  This means making the binding functions actually call the OS-specific
  system calls and really do binding, while the XML backend would otherwise
  provide empty hooks just returning success.
  This can be used for efficiency reasons to first detect the topology once,
  save it to an XML file, and quickly reload it later through the XML
  backend, but still having binding functions actually do bind.



\page embed Embedding hwloc in other software

It can be desirable to include hwloc in a larger software package (be
sure to check out the LICENSE file) so that users don't have to
separately download and install it before installing your software
(after all, hwloc is a tiny little project -- why make users bother
with it?).

When used in "embedded" mode, hwloc will:

- not install any header files
- not build or install any executables
- not build libhwloc.* -- instead, it will build libhwloc_embedded.*

There are two ways to put hwloc into "embedded" mode.  From the
configure command line:

\verbatim
shell$ ./configure --enable-included-mode ...
\endverbatim

Or by directly integrating hwloc's m4 configure macro in your
configure script and invoking a specific macro to enable the embedded
mode.

Every project is different, and there are many different ways of
integrating hwloc into yours.  What follows is <em>one</em> example of
how to do it.

Copy the hwloc directory in your source tree and include the hwloc.m4
file in your configure script -- perhaps with the following line in
acinclude.m4 (assuming the use of Automake):

\verbatim
m4_include(path/to/hwloc.m4)
\endverbatim

The following macros can then be used from your configure script (only
HWLOC_INIT <em>must</em> be invoked if using the m4 macros):

- HWLOC_SET_SYMBOL_PREFIX(foo_): Tells the hwloc to prefix all of
  hwloc's types and public symbols with "foo"; meaning that function
  hwloc_init() becomes foo_hwloc_init().  This is recommended behavior
  if you are including hwloc in a larger project -- it is possible
  that your software will be combined with other software that also
  includes hwloc.  If you both use different symbol prefixes, there
  will be no type/symbol clashes, and everything will compile and link
  successfully.  If you both include hwloc and do not change the
  symbol prefix, it is likely that you will get multiple symbol
  definitions when linking if an external hwloc is linked against your
  library / application.  Enum values are prefixed with an upper-case
  translation if the prefix supplied.  For example,
  HWLOC_SET_SYMBOL_PREFIX(foo_) will result in both foo_hwloc_init()
  and FOO_HWLOC_OBJ_SYSTEM.

- HWLOC_INIT(config-dir-prefix, action-upon-success, action-upon-failure):
  Invoke the hwloc tests and setup the hwloc tree to build.  A
  traversal of "make" into the hwloc directory should build everything
  (it is safe to list the hwloc directory in the SUBDIRS of a
  higher-level Makefile.am, for example).  ***hwloc_INIT must be
  invoked after the SET_SYMBOL_PREFIX macro.*** The first argument is
  the prefix to use for AC_OUTPUT files -- it's where the hwloc tree
  is located relative to $top_srcdir.  Hence, if your embedded hwloc
  is located in the source tree at contrib/hwloc, you should pass
  [contrib/hwloc] as the first argument.

- HWLOC_DO_AM_CONDITIONALS: If you embed hwloc in a larger project and
  build it conditionally (e.g., if HWLOC_INIT is invoked
  conditionally), you must unconditionally invoke
  HWLOC_DO_AM_CONDITIONALS to avoid warnings from Automake (for the
  cases where hwloc is not selected to be built).  This macro is
  necessary because hwloc uses some AM_CONDITIONALs to build itself,
  and AM_CONDITIONALs cannot be defined conditionally.  Note that it
  is safe (but unnecessary) to call HWLOC_DO_AM_CONDITIONALS even if
  HWLOC_INIT is invoked unconditionally.

Here's an example of integrating with a larger project named sandbox:

\verbatim
shell$ cd sandbox
shell$ cp -r /somewhere/else/hwloc-<version> my-embedded-hwloc
shell$ echo 'm4_include(my-embedded-hwloc/config/hwloc.m4)' >> acinclude.m4
shell$ edit Makefile.am
...add "my-embedded-hwloc" to SUBDIRS...
...add "$(top_builddir)/my-embedded-hwloc/src/libhwloc_included.la" to
   sandbox's executable's LDADD line...
...add "-I$(top_builddir)/my-embedded-hwloc/include" to AM_CPPFLAGS
shell$ edit configure.ac
...add "HWLOC_SET_SYMBOL_PREFIX(sandbox_hwloc_)" line...
...add "HWLOC_INIT([my-embedded-hwloc], [happy=yes], [happy=no])" line...
...add error checking for happy=no case...
shell$ edit src/my_program.c
...add #include <hwloc.h>...
...add calls to sandbox_hwloc_init()...
\endverbatim

Now you can bootstrap, configure, build, and run the sandbox as normal
-- all calls to "sandbox_hwloc_*" will use the embedded hwloc rather
than any system-provided copy of hwloc.




\page switchfromplpa How to switch from PLPA to hwloc?

Although PLPA and hwloc share the same ideas, their programming interfaces
are different. Converting an application from PLPA to hwloc will require
some thinking that is explained below.


\section switchfromplpa_caching Topology context vs. caching

First, all hwloc functions take a \p topology parameter. It serves as an
internal storage for the result of the topology discovery. It somehow
replaces PLPA caching abilities and may even let you manipulate multiple
topologies as the same time if needed.

Thus, all program should first run hwloc_topology_init() and
hwloc_topology_init() as they did plpa_init() in the past.


\section switchfromplpa_hierarchy Hierarchy vs. Core@Socket

PLPA was designed to manipulate cores within sockets. hwloc offers
much more different types of objects and stores them within a tree
of resources.

To emulate PLPA model, it is possible to find sockets using functions
such as hwloc_get_obj_by_type().
Iterating over sockets is also possible using hwloc_get_next_obj_by_type().
Then, finding a core within a socket may be done using
hwloc_get_obj_inside_cpuset_by_type()
or hwloc_get_next_obj_inside_cpuset_by_type().

It is also possible to directly find an object below another object
using hwloc_get_obj_below_by_type()
(or hwloc_get_obj_below_array_by_type()).


\section switchfromplpa_indexes Logical vs. Physical/OS indexes

hwloc manipulates logical indexes, which means indexes with regards to
the ordering of objects in the hierarchical tree.
Physical or OS indexes may be entirely hidden if not strictly required.
The reason for this is that physical/OS indexes may change with the OS
or with the BIOS version.
They may be non-consecutive, multiple objects may have the same
physical/OS indexes, making their manipulation tricky and highly
non-portable.

It is still possible to retrieve physical/OS indexes through the \p
os_index field of objects, but it should be avoided as much as possible,
except for pretty-printing purposes.

::HWLOC_OBJ_PROC objects are supposed to have different physical/OS indexes
since the OS uses them for binding.
The \p os_index field of these objects provides the identifier that may
be used for such binding, and hwloc_get_proc_obj_by_os_index() finds the
object associated with a OS index.
However, again, these conversion methods should not be used for actual
binding since hwloc offers its own binding model using the \p cpuset
field of objects.
These cpusets may be duplicated, modified, combined, ... (see hwloc/cpuset.h
for details) and then passed to hwloc_set_cpubind() or so for actual binding.


\section switchfromplpa_counting Counting specification

PLPA offerzs a countspec parameter to specify whether counting all CPUs,
only the online ones or only the offline ones.
However, some OS do not expose the topology of offline CPUs.
Also, some of them may not be available to the current application
due to administrator's restrictions.
Also, modern processors let you shutdown a single thread of a core,
making some of the PLPA features irrelevant.

hwloc stores in the hierarchical tree of objects all CPUs that have
known topology information.
It then provides the applications with several cpusets that contain
the list of CPUs that are actually known, that have topology information,
that are online, or that are available to the application.
These cpusets may be retrieved with hwloc_topology_get_online_cpuset()
and other similar functions to filter the object that are relevant
or not.

*/
