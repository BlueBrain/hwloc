/*
 * Copyright © 2009 CNRS, INRIA, Université Bordeaux 1
 *
 * This software is a computer program whose purpose is to provide
 * abstracted information about the hardware topology.
 *
 * This software is governed by the CeCILL-B license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL-B
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-B license and that you accept its terms.
 */
/*! \mainpage Libtopology

\section Introduction

libtopology provides a portable abstraction (across OS, versions, architectures,
...) of the hierarchical topology of modern architectures. It primarily aims at
helping high-performance computing application with gathering information about
the hardware so as to exploit it accordingly and efficiently.

libtopology provides a hierarchical view of the machine, NUMA memory nodes,
sockets, shared caches, cores and simultaneous multithreading. It also gathers
various attributes such as cache and memory information.

libtopology supports the following operating systems:

<ul>
  <li> Linux (including old kernels not having sysfs topology information, with
  knowledge of cpusets and offline cpus)
  <li> Solaris
  <li> AIX
  <li> Darwin
  <li> OSF/1 (aka. Tru64)
  <li> Windows
  <li> For other OSes, only the number of processors is available for now.
</ul>

For development and debugging purposes, libtopology also offers the ability to
work on fake topologies:

<ul>
  <li> Symmetrical tree of resources generated from a list of level arities
  <li> Remote machine simulation through the gathering of Linux sysfs topology files
</ul>

libtopology may also display the topology in a convenient format, either in
graphical mode, or by exporting in PDF, PNG, FIG, ... format, or in text mode
(see Examples below).

libtopology offers a programming interface for manipulating topologies and
objects. It also brings a powerful cpu bitmap API that is used to describe
topology objects location on physical/logical processors. See the \ref interface interface
below. It may also be used to binding applications onto certain cores or
memory nodes. Several utility programs are also provided to ease command-line
manipulation of topology objects, binding of processes, ...

\section installation Installation

libtopology (http://libtopology.gforge.inria.fr/) is available under the CeCILL-B license (BSD-like).
It is hosted by the INRIA Gforge (http://gforge.inria.fr/projects/libtopology/).
The current SVN snapshot can be fetched with:

<ul>
 <li>svn checkout svn://scm.gforge.inria.fr/svn/libtopology/trunk libtopology
 <li>cd libtopology
 <li>autoreconf -ifv
</ul>

Note that autoconf >=2.60, automake >=1.10 and libtool >=2.2.6 are required in that case.

Installation by itself is as usual:

<ul>
 <li>./configure --prefix=...
 <li>make
 <li>make install
</ul>

Lstopo's fig support is always available. To get support for pdf, ps and png
support, cairo is needed. To get support for xml, libxml2 is needed.

\section examples Examples

 On a 4-socket 2-core machine with hyperthreading, the \c lstopo tool may
 show the following outputs:

\image html dudley.png
\image latex dudley.png width=\textwidth

\code
Machine(15GB)
  Socket#0 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#0
      P#8
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#4
      P#12
  Socket#1 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#1
      P#9
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#5
      P#13
  Socket#2 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#2
      P#10
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#6
      P#14
  Socket#3 + L3Cache(4096KB)
    L2Cache(1024KB) + L1Cache(16KB) + Core#0
      P#3
      P#11
    L2Cache(1024KB) + L1Cache(16KB) + Core#1
      P#7
      P#15
\endcode

 On a 8-socket 2-core Opteron NUMA machine, the \c lstopo tool may
 show the following outputs:

\image html hagrid.png
\image latex hagrid.png width=\textwidth

\code
Machine(62GB)
  NUMANode#0(8190MB) + Socket#0
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#0
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#1
  NUMANode#1(8192MB) + Socket#1
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#2
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#3
  NUMANode#2(8192MB) + Socket#2
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#4
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#5
  NUMANode#3(8192MB) + Socket#3
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#6
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#7
  NUMANode#4(8192MB) + Socket#4
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#8
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#9
  NUMANode#5(8192MB) + Socket#5
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#10
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#11
  NUMANode#6(8192MB) + Socket#6
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#12
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#13
  NUMANode#7(8192MB) + Socket#7
    L2Cache(1024KB) + L1Cache(64KB) + Core#0 + P#14
    L2Cache(1024KB) + L1Cache(64KB) + Core#1 + P#15
\endcode

 On a 2-socket quad-core Xeon (pre-Nehalem ones assembling 2 dual-core dies into each socket):

\image html emmett.png
\image latex emmett.png width=\textwidth

\code
Machine(15GB)
  Socket#0
    L2Cache(4096KB)
      L1Cache(32KB) + Core#0 + P#0
      L1Cache(32KB) + Core#1 + P#4
    L2Cache(4096KB)
      L1Cache(32KB) + Core#2 + P#2
      L1Cache(32KB) + Core#3 + P#6
  Socket#1
    L2Cache(4096KB)
      L1Cache(32KB) + Core#0 + P#1
      L1Cache(32KB) + Core#1 + P#5
    L2Cache(4096KB)
      L1Cache(32KB) + Core#2 + P#3
      L1Cache(32KB) + Core#3 + P#7
\endcode

\section interface Interface example

This section shows how to use libtopology with an small example \c topo-hello.c
that just prints the topology and binds itself to the first processor of the
second core of the machine.

Libtopology provides a pkg-config object, so compiling the example boils down to

\verbatim
CFLAGS+=$(pkg-config --cflags topology)
LDLIBS+=$(pkg-config --libs topology)
cc topo-hello.c $(CFLAGS) -o topo-hello $(LDLIBS)
\endverbatim

   \code
/* topo-hello.c */
#include <topology.h>

static void print_children(topo_topology_t topology, topo_obj_t obj, int depth)
{
	char string[128];
	int i;

	topo_obj_snprintf(string, sizeof(string), topology, obj, "#", 0);
	printf("%*s%s\n", 2*depth, "", string);
	for (i = 0; i < obj->arity; i++)
		print_children(topology, obj->children[i], depth + 1);
}

int main(void)
{
	/* Topology object */
	topo_topology_t topology;

	/* Allocate and initialize topology object.  */
	topo_topology_init(&topology);

	/* ... Put detection configuration here...
	   See topology_configuration.  */

	/* Perform the topology detection.  */
	topo_topology_load(topology);


	/* Get topology information.  */
	struct topo_topology_info topoinfo;
	topo_topology_get_info(topology, &topoinfo);


	/* Walk the topology with an array style.  */
	unsigned depth, i;
	char string[128];
	for (depth = 0; depth < topoinfo.depth; depth++) {
		for (i = 0; i < topo_get_depth_nbobjs(topology, depth); i++) {
			topo_obj_snprintf(string, sizeof(string), topology,
					topo_get_obj(topology, depth, i), "#", 0);
			printf("%s\n", string);
		}
	}

	/* Walk the topology with a tree style.  */
	print_children(topology, topo_get_system_obj(topology), 0);


	/* Find out where cores are, or else smaller sets of CPUs.  */
	depth = topo_get_type_or_below_depth(topology, TOPO_OBJ_CORE);

	/* Get last one.  */
	topo_obj_t obj = topo_get_obj(topology, depth, topo_get_depth_nbobjs(topology, depth) - 1);
	if (!obj)
		return 0;

	/* Get its cpuset.  */
	topo_cpuset_t cpuset = obj->cpuset;

	/* Get only one logical processor (in case the core is SMT/hyperthreaded).  */
	topo_cpuset_singlify(&cpuset);

	/* And bind there.  */
	if (topo_set_cpubind(&cpuset)) {
		char s[TOPO_CPUSET_STRING_LENGTH + 1];
		topo_cpuset_snprintf(s, sizeof(s), &obj->cpuset);
		printf("Couldn't bind to cpuset %s\n", s);
	}


	/* Destroy topology object.  */
	topo_topology_destroy(topology);

	return 0;
}
   \endcode

\section bugs Bugs and questions

Bug reports and questions should be sent to the devel mailing list (http://lists.gforge.inria.fr/cgi-bin/mailman/listinfo/libtopology-devel).

\section Credits

\c libtopology is developed by the INRIA Runtime Team-Project (http://runtime.bordeaux.inria.fr/) (headed by Raymond Namyst http://dept-info.labri.fr/~namyst/).

*/
