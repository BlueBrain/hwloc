* windows

* uniformize SMT / PROC / thread names
  + if we keep a "proc" level at the bottom, should we make its type
    ignorable for real? otherwise, we could get L1 objects at the bottom

* generalize TOPO_FLAGS_IGNORE_THREADS filtering
  + remove all thread items but the first one
    so that we bind to a single OS cpu in the end
  + applicable to any other level type?

* change memory_kB[] and physical_index[] into scalars now that we know that we'll probably never merge level for real
  + application that want all information just have to not merge things

* integrate marcel split quirk?
  + split for real, just explain how to split?
  + keep fake level type?
* integrate synthetic topology support

* factorize all /sys/.../node/meminfo reading routines
* move DMI reading info to topology-linux.c

* use topology_allocator for real, including in strdup
* how does the application change the memory allocator?
  + another argument in lt_topo_init() ?
  + or more generic way with an array or { int type; void *obj; }
    to pass the fsys_root_path, memory_allocator, ...

* conversion between strings and cpuset:
  void lt_string_to_mask(const char *string, lt_cpuset_t *cpuset)
  void lt_mask_to_string(lt_cpuset_t *cpuset, const char *string)
* conversion between cpuset and the lowest ancestors covering it
  void lt_mask_to_ancestor(lt_cpuset_t *cpuset, lt_level_t *level)
* conversion between cpuset and an array of highest levels covering exactly it
  int lt_mask_to_levels(lt_cpuset_t *cpuset, lt_level_t *levels, int max)
 
API:
* add a lt_topo_merge() merging everything possible (or just a level)
  + or add som flags to lt_topo_init
* add lt_topo_split()? 
* add a way to extract sched_setaffinity masks from arrays of levels (OR'ed)
  + or bind directly?
* add a way to extract libnuma-friendly masks of nodes from arrays of levels (OR'ed)
  + no level = empty mask, and we may want an easy alias for "whole machine"
* add reverse-routines converting sched_getaffinity or libnuma masks into a ancestor level
* provide traversal functions instead of pointers in structures?
* LT_LEVEL_MEMORY_L*: what about L4 someday? Use resource "types" instead and
  add a depth for caches.
  + make cache size/depth/type, memory node size + hugepagefree a resource attribute
* hide some things from lt_topo?
* there could be several size for huge pages
* rename "level" into "resource" or "object"


Binding tool for OAR, MPI, Hydra, MPI+OpenMP:
* lt_taskset --ncpus 2 --near 3
  bind process on 2 cores near physical proc id 3
* lt_taskset --index 4
  bind process on 4th processor in a topology-aware numbering
* lt_taskset --ncpus 2 --index 4
  bind process on the 4th set of 2 physically close ids in a topology-aware numbering (used by ggrun when launching 4 process with 2 threads)
* lt_taskset --on <Machine/Node/Die/L3/L2/Core/L1/Proc/<depth>>:<index>
  bind process on object #index in level given by name or depth
* tools to create masks and bind using them
