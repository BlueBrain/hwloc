API

Split API into two levels?
- low-level API with sort of Turing power
- high-level API that give examples how use the low-level API. Could be only
  static inlines.


* clarify the API to obtain the number of nodes, procs, cores, ...

* cache or node specific functions?
  + get nodes covering a cpuset?
  + get shared cache*S* covering a cpuset?

* topomask: add an option to request a cpuset containing of n close entries
  among the generated cpuset

* have an easy way to get a valid full set (alias on get_machine_object()->cpuset) ?

* expose the internal conversion from cpuset to sched_setaffinity mask?
  + reverse routine?

Doc
===
* complete doc
* draw relations between objects (tree/levels/pointers)

Support
=======
* add support for amd magny-cours "multi-node-cpu", probably by reading 
  cpu_node_siblings/id if available (in 2.6.31+).
  should look like multiple sockets in single numa node?
  but looks like their L3s are hardware-merged

* there could be several size for huge pages

* add some padding in the object attributes so that we can add new stuff
  without breaking the ABI?
  + for instance if we move dmi info in the machine attributes
  + for instance if we add the cache type
  + or make attribute a pointer?  (ST: I'd vote for that)

* integrate marcel split quirk?
  + split for real, just explain how to split?
    - just return an ordered array?

* use topology_allocator for real, including in strdup
  + add topo_set_allocator() to be called before _init()

* Kerrighed: Use
int migrate (pid_t pid, int destination_node);
int migrate_self (int destination_node);
int thread_migrate (int thread_id, int destination_node);

* move dmi_* to a machine object?

* lstopo-nox
  + disable xml as well?  It only depends on zlib

* make test-topologies even more flexible so that we may export to xml files or so (i.e. not to stdout)

Binding
=======
* topo_set_cpubind(pid, ...) which type for pid? POSIX says that pid_t is a
  signed integer type
* topo_set_cpubind for threads, pb: depending on the OS, the function takes a
  pthread_t or a kernel tid.
* topo_set_membind()
  + reverse routine?
  + no level = empty mask, and we may want an easy alias for "whole machine"
* Some OSes do not provide strict binding, only relaxed binding.

* make them do nothing if passed a fake topology?
  + so applications can just always call them and still have synthetic tests.

Binding tool for OAR, MPI, Hydra, MPI+OpenMP:
* topo_taskset --ncpus 2 --near 3
  bind process on 2 cores near physical proc id 3
* topo_taskset --index 4
  bind process on 4th processor in a topology-aware numbering
* topo_taskset --ncpus 2 --index 4
  bind process on the 4th set of 2 physically close ids in a topology-aware numbering (used by ggrun when launching 4 process with 2 threads)
* tools to create masks and bind using them


Ports
=====

HP-UX:
   mpctl(MPC_GETNUMSPUS_SYS/MPC_GETFIRSTSPU_SYS/MPC_GETNEXTSPU_SYS)
   mpctl(MPC_GETNUMSPUS/MPC_GETFIRSTSPU/MPC_GETNEXTSPU)
   pthread_processor_bind_np(PTHREAD_GETFIRSTSPU_NP/PTHREAD_GETNEXTSPU_NP)
   sysconf(_SC_CCNUMA_SUPPORT)
   mpctl(MPC_GETNUMLDOMS_SYS/MPC_GETFIRSTLDOM_SYS/MPC_GETNEXTLDOM_SYS/MPC_LDOMSSPUS_SYS/MPC_SPUTOLDOM)
   + -_SYS

   pthread_num_ldoms_np() / mpctl(MPC_GETNUMLDOMS)
   pthread_ldom_id_np(PTHREAD_GETFIRSTLDOM_NP/PTHREAD_GETNEXTLDOM_NP)
   mpctl(MPC_GETFIRSTLDOM/MPC_GETNEXTLDOM)
   pthread_num_ldomprocs_np()
   mpctl(MPC_LDOMSPUS)

   mpctl(MPC_SETPROCESS_FORCE)
   mpctl(MPC_SETLDOM)
   pthread_processor_bind_np(PTHREAD_BIND_FORCED_NP)
   pthread_ldom_bind_np()

  since 11i 1.6:
   _SC_PSET_SUPPORT
   pset_create/destroy/assign/setattr
   pset_ctl/getattr
   pset_bind()
   pthread_pset_bind_np()

   mmap/shmget: +MAP/IPC_MEM_INTERLEAVED, MAP/IPC_MEM_LOCAL,
   MAP_IPC/MEM_FIRST_TOUCH

Irix:
  Â sysmp(MP_NPROCS/MP_NAPROCS/MP_STAT)
   NUMA: /hw : /hw/nodenum/0 -> /hw/module/1/slot/n1/node
   /hw/cpunum/0 -> /hw/module/1/slot/n1/node/cpu/a
   check through getmntent where hwgfs is mounted
   sysmp(MP_MUSTRUN/MP_MUSTRUN_PID)
   PTHREAD_SCOPE_BOUND_NP
   pthread_setrunon_np()
   process_cpulink()
   mld_create() mldset_create() numa_acreate() migr_range_migrate()

QNX:
   _syspage_ptr() SYSPAGE_ENTRY(entry)
   ThreadCtl/Thread_ctl_r(_NTO_TCTL_RUNMASK)

BSD:
   sys/sched.h: sched_bind/sched_unbind, but that's in-kernel only for now.
