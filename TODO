API

* reverse type_order?
  + it currently increases with depth
  + but it's used as if it decreased with depth in get_type_or_order_depth

* Rename topo_get_obj_type_order into topo_get_type_order?

* topomask: add an option to request a cpuset containing of n close entries
  among the generated cpuset

* expose the internal conversion from cpuset to sched_setaffinity mask?
  + reverse routine?

Doc
===
* complete doc
* draw relations between objects (tree/levels/pointers)
* automatically generate the pngs?
* Glossary?

* add examples for (example dir?)
  + finding all nodes near a cpuset
  + obtain the number of nodes, procs, cores, ...
  + iterate through caches above an object?
  + get a valid full set (alias on get_machine_object()->cpuset) ?

Support
=======
* add support for amd magny-cours "multi-node-cpu", probably by reading 
  cpu_node_siblings/id if available (in 2.6.31+).
  should look like multiple sockets in single numa node?
  but looks like their L3s are hardware-merged

* there could be several size for huge pages

* add some padding in the object attributes so that we can add new stuff
  without breaking the ABI?
  + for instance if we move dmi info in the machine attributes
  + for instance if we add the cache type
  + or make attribute a pointer?  (ST: I'd vote for that)

* integrate marcel split quirk?
  + split for real, just explain how to split?
    - just return an ordered array?

* move dmi_* to a machine object?

* lstopo-nox
  + disable xml as well?  It only depends on zlib

Binding
=======
* Add the topology parameter to be able to distinguish a cpuset with all cpus
  (-> unbind), and distinguish between simple linux, kerrighed, fake, ....

* topo_set_cpubind(pid, ...) which type for pid? POSIX says that pid_t is a
  signed integer type
* topo_set_cpubind for threads, pb: depending on the OS, the function takes a
  pthread_t or a kernel tid.
* topo_set_membind()
  + reverse routine?
  + no level = empty mask, and we may want an easy alias for "whole machine"
* Some OSes do not provide strict binding, only relaxed binding.

* make them do nothing if passed a fake topology?
  + so applications can just always call them and still have synthetic tests.

Binding tool for OAR, MPI, Hydra, MPI+OpenMP:
* topo_taskset --ncpus 2 --near 3
  bind process on 2 cores "near" physical proc id 3

Ports
=====

HP-UX:
   mpctl(MPC_GETNUMSPUS_SYS/MPC_GETFIRSTSPU_SYS/MPC_GETNEXTSPU_SYS)
   mpctl(MPC_GETNUMSPUS/MPC_GETFIRSTSPU/MPC_GETNEXTSPU)
   pthread_processor_bind_np(PTHREAD_GETFIRSTSPU_NP/PTHREAD_GETNEXTSPU_NP)
   sysconf(_SC_CCNUMA_SUPPORT)
   mpctl(MPC_GETNUMLDOMS_SYS/MPC_GETFIRSTLDOM_SYS/MPC_GETNEXTLDOM_SYS/MPC_LDOMSSPUS_SYS/MPC_SPUTOLDOM)
   + -_SYS

   pthread_num_ldoms_np() / mpctl(MPC_GETNUMLDOMS)
   pthread_ldom_id_np(PTHREAD_GETFIRSTLDOM_NP/PTHREAD_GETNEXTLDOM_NP)
   mpctl(MPC_GETFIRSTLDOM/MPC_GETNEXTLDOM)
   pthread_num_ldomprocs_np()
   mpctl(MPC_LDOMSPUS)

   mpctl(MPC_SETPROCESS_FORCE)
   mpctl(MPC_SETLDOM)
   pthread_processor_bind_np(PTHREAD_BIND_FORCED_NP)
   pthread_ldom_bind_np()

  since 11i 1.6:
   _SC_PSET_SUPPORT
   pset_create/destroy/assign/setattr
   pset_ctl/getattr
   pset_bind()
   pthread_pset_bind_np()

   mmap/shmget: +MAP/IPC_MEM_INTERLEAVED, MAP/IPC_MEM_LOCAL,
   MAP_IPC/MEM_FIRST_TOUCH

Irix:
  Â sysmp(MP_NPROCS/MP_NAPROCS/MP_STAT)
   NUMA: /hw : /hw/nodenum/0 -> /hw/module/1/slot/n1/node
   /hw/cpunum/0 -> /hw/module/1/slot/n1/node/cpu/a
   check through getmntent where hwgfs is mounted
   sysmp(MP_MUSTRUN/MP_MUSTRUN_PID)
   PTHREAD_SCOPE_BOUND_NP
   pthread_setrunon_np()
   process_cpulink()
   mld_create() mldset_create() numa_acreate() migr_range_migrate()

QNX:
   _syspage_ptr() SYSPAGE_ENTRY(entry)
   ThreadCtl/Thread_ctl_r(_NTO_TCTL_RUNMASK)

BSD:
   sys/sched.h: sched_bind/sched_unbind, but that's in-kernel only for now.
