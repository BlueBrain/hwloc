advertise how to change the max numb of cpus

API

* Do we actually need hwloc_get_type_order() or would hwloc_compare_types() be enough?

* topomask: add an option to request a cpuset containing of n close entries
  among the generated cpuset

* internationalize the output of lstopo? object types and memory size units

* support plpa core@socket syntax in hwloc-bind

Doc
===
* complete doc
* automatically generate the pngs?

* document all environment variables properly
* explain how to switch to a XML-saved topology to improve startup time
  without disabling the is_thissystem flag

* add examples for (example dir?)
  + finding all nodes near a cpuset
  + obtain the number of nodes, procs, cores, ...
    * if no numa node, do we get 0 or 1 with which function?
  + iterate through caches above an object?
  + get a valid full set (alias on get_machine_object()->cpuset) ?
  + difference between machine and system

Support
=======
* add linux cgroup support
  (seems to be cpuset-exclusive?)
  if /proc/self/cgroup exists and is not empty, take the path from the 3rd
  ':'-separated field
  read cpuset cpulist in /dev/cgroup/<path>/cpuset.cpus
  read cpuset memlist in /dev/cgroup/<path>/cpuset.mems

* add support for amd magny-cours "multi-node-cpu", probably by reading 
  cpu_node_siblings/id if available (in 2.6.32+).
  should look like multiple sockets in single numa node?
  but looks like their L3s are hardware-merged

* there could be several size for huge pages

* solaris' cc doesn't seem to support array range ([0 ... n]) initialization.

* split configure in two parts
  + main configure checks for packaging things
    (documentation, building tools, cairo, tests, ...)
  + sub configure in library checks for library-only things
    (OS-specific topology features, XML, ...)
  so that we can build the lib without anything else
  (MPICH2/Hydra or OpenMPI will directly call the library configure
   as they do with PLPA).

* parallelize the discovery ? :)

* Add measurement-based backend
* Add (x86) cpuid backend to quickly workaround kernel bugs?

Binding
=======
* add hwloc_get_cpubind ? and the other cpubind variants ?
  + A few OSes don't provide it (e.g. AIX, OSF, solaris), it does not make sense
  for a process when its threads are bound here and there.

* add hwloc_set_membind(topology, beginaddr, endaddr, HWLOC_MEMBIND_BIND/FIRSTTOUCH/INTERLEAVE, hwloc_cpuset_t)
  + size instead of endaddr?
  + if beginaddr=endaddr=NULL, setmempolicy?
  + reverse routine?
  + no level = empty mask, and we may want an easy alias for "whole machine"
* allocation with a given policy
  + get Samuel's code from pm2's marcel_sysdep.c
* apply a policy to a given area (not all OSes support that).

Binding tool for OAR, MPI, Hydra, MPI+OpenMP:
* hwloc_taskset --ncpus 2 --near 3
  bind process on 2 cores "near" physical proc id 3

Ports
=====

XML:
   NUMA distances

Irix:
  Â sysmp(MP_NPROCS/MP_NAPROCS/MP_STAT)
   NUMA: /hw : /hw/nodenum/0 -> /hw/module/1/slot/n1/node
   /hw/cpunum/0 -> /hw/module/1/slot/n1/node/cpu/a
   check through getmntent where hwgfs is mounted
   sysmp(MP_MUSTRUN/MP_MUSTRUN_PID)
   PTHREAD_SCOPE_BOUND_NP
   pthread_setrunon_np()
   process_cpulink()
   mld_create() mldset_create() numa_acreate() migr_range_migrate()

QNX:
   _syspage_ptr() SYSPAGE_ENTRY(entry)
   ThreadCtl/Thread_ctl_r(_NTO_TCTL_RUNMASK)

BSD:
   sys/sched.h: sched_bind/sched_unbind, but that's in-kernel only for now.

Cray Catamount?

